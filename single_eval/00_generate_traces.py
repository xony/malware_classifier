## this script will read all the samples from the SAMPLE_DIRECTORY and run traces
#
# the traces will be saved to the TRACE_DIRECTORY
# under the name of the apk
#
# this script will also take care of launching the corresponding emulator,
# installing the apk and then running the monkey runner
#

import time
import subprocess
import os, re
import argparse
import select
import signal

from config import *

def sdir(filename):
    return SAMPLE_DIRECTORY+"/"+filename
def tdir(filename,appname):
    if SAMPLES_BENIGN in filename:
        cleaned_filename = filename[len(SAMPLES_BENIGN)+1:]
        return BENIGN_TRACE_DIRECTORY + "/" + cleaned_filename + '.' + appname +  "/"
    elif SAMPLES_MALICIOUS in filename:
        cleaned_filename = filename[len(SAMPLES_MALICIOUS)+1:]
        return MALICIOUS_TRACE_DIRECTORY + "/" + cleaned_filename + '.' + appname +  "/"

# define the exception for no main activity
class NoMainActivityError(Exception):
    """Exception raised for no startable Activity found in APK.
    """
    
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class EmulatorTimedOutError(Exception):
    """Exception raised because AVD timed out.
    """

    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class Alarm(Exception):
    pass

# now we need to map the filenames to the actual activity names

def get_package_name(file_names):
    # this function gets the package names from the xml file and returns a dict
    values = {}
    for b in file_names:
        catstr = AAPT_DIR +" d xmltree "+ b +" AndroidManifest.xml"
        p = subprocess.Popen(catstr.split(), stdout=subprocess.PIPE)
        found = False
        for line in iter(p.stdout.readline, b''):
	    if "package=" in line:
                found = True
		package_name = re.search('(?<=")(.*?)(?=")', line).group(0)
		values[b] = package_name
		break
        if found == False:
            print "Did not find package name for ", b
    return values

def get_launchable_activity(file_name):
    # this function gets the launchable activity name from the xml file and returns it
        catstr = AAPT_DIR +" dump badging "+ file_name
        p = subprocess.Popen(catstr.split(), stdout=subprocess.PIPE)
	found = False
        for line in iter(p.stdout.readline, b''):
	    if "launchable-activity" in line:
		activity_name = re.search("(?<=name=')(.*?)(?=')", line).group(0)
		found = True
		break
	if found:
	    return activity_name
	else:
	    raise NoMainActivityError("Main Activity could not be parsed...")




def adb_command(command):
    try:
	p = subprocess.check_output(["/usr/bin/adb"] + command.split(), stderr=subprocess.STDOUT)
	return p
    except subprocess.CalledProcessError as e:
	return "command returned error"

def adb_async(command):
    p = subprocess.Popen(["/usr/bin/adb"] + command.split(), stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    return p

def wait_for_adb(emu,wait_time=300):
    pm_found = False
    attempts = 0
    wait_period = 5
    while not pm_found and (attempts*wait_period) < wait_time:
      # assume the 'adb shell pm path android' command will always
      # return 'package: something' in the success case
      output = adb_command("shell pm path android")
      if "package:" in output:
        pm_found = True
      else:
        time.sleep(wait_period)
        attempts += 1
    if not pm_found:
        raise EmulatorTimedOutError("Emulator timed out after %s seconds" % wait_time) 



# now we have the emulator up and running, we may proceed to install the apk

def run_instances(names, required_app_nr=0):
    '''
	runs the traces from a dictionary containing file and appname
	returns how many runs were successful

	cannot run on apks which have no startable activity
    '''
    hasMainActivity = len(names)
    app_nr = 0
    for (filename, appname) in names.iteritems():
	current_run = 0
	print "filename ", filename, " appname ", appname, " app_nr ", app_nr
	app_nr += 1

        if app_nr <= required_app_nr:
            print "skipping app_nr ", app_nr -1
            continue
	
	# we will also need the launchable activity
	try:
	    activity_name = get_launchable_activity(filename)	
	except NoMainActivityError:
	    hasMainActivity -= 1
	    continue

	while current_run < MAX_RUNS:

	    # first we need to start the emulator and wait for it to be done starting
	    catstr = EMULATOR_DIR+ AVD_START_STRING 
	    emulator_instance = subprocess.Popen(catstr.split())
	    
            try:
	        wait_for_adb(emulator_instance)
            except EmulatorTimedOutError:
                print "Emulator timed out, retrying..."
                emulator_instance.kill()
                time.sleep(10)
                continue

	    # now we can install the app
	    res = adb_command("install " + filename )
	    if res.endswith("Success\r\n"):
	        print "sucessfully installed ",appname," via adb"
	    else:
	        print "error calling adb install with ", filename
	        print "try this: ", repr(res)
	        #continue

	    # open the lockscreen
	    adb_command("shell input keyevent 82")


	    instance_run = 0

	    while instance_run < RUNS_PER_INSTANCE and current_run < MAX_RUNS: 		
		# increment the variables
		instance_run += 1
		current_run += 1

		# once the apk is installed, we need to prepare the monitoring client
	    	adb_command("shell am force-stop "+ appname)	
	    	adb_command("shell am force-stop "+ MONITORING_CLIENT_NAME)	
	    	
	    	# remove all tracefiles from runs before
	    	all_tracefiles = adb_command("shell ls -d /sdcard/trace*").translate(None, '\r').splitlines()
	    	for tracefile in all_tracefiles:
	    	    adb_command("shell rm -r "+tracefile)

	    	# start the actual app activity
	    	#   we do this because the monitoring client sometimes does not catch the start of a new activity
	    	adb_command("shell am start "+appname+"/"+activity_name)
	    	print "activity started... with: ", appname, " ", activity_name
	    	time.sleep(2)

	    	# start the monitoring activity
	    	adb_command("shell am start -n "+MONITORING_CLIENT_NAME+"/.MonitoringClientActivity")
	    	adb_command("shell input tap 360 900") # this presses on the start for 2 min button
	    	print "monitoring started..."
	    	time.sleep(3)


		# switch to the activity again
		adb_command("shell am start "+appname+"/"+activity_name)
	    	time.sleep(2)



    	    	# start the monkey runner
	    	p = adb_async("shell monkey --throttle 100 -p "+appname+" -v "+str(NUM_MONKEY_EVENTS)+" -s 981 --ignore-crashes --ignore-security-exceptions --ignore-timeouts")
	    	print "monkey is running!"

                monkey_start_time = time.time()
                monkey_running = True

                poll_obj = select.poll()
                poll_obj.register(p.stdout, select.POLLIN)

                def alarm_handler(signum, frame):
                    raise Alarm

                signal.signal(signal.SIGALRM, alarm_handler)
                signal.alarm(5*60)  # 5 minutes


		# check for abort or sucessful run
                try:
                    while(monkey_running and time.time() - monkey_start_time < TIMEOUT):
                        poll_result = poll_obj.poll(0)
                        if poll_result:
                            line = p.stdout.readline()
                            if "Monkey finished" in line or "Monkey aborted" in line:
                                monkey_running = False
                        else:
                            time.sleep(2)
                    signal.alarm(0)
                except Alarm:
                    # we took to long, restart the shit
                    print "error: Monkey not responding, restarting..."
                    emulator_instance.terminate()
                    time.sleep(10)
                    break
		
	    	time.sleep(2) 
	    	print "monkey has finished... killing!"

	    	# force stop the monitoring and the activity
	    	adb_command("shell am force-stop "+ appname)
            	adb_command("shell am force-stop "+ MONITORING_CLIENT_NAME)
	    
                # create the dir if it does not exist
                #if not os.path.exists(tdir(filename, appname)):
                #    os.makedirs(tdir(filename, appname))	

	    	# save the tracefiles for the app from the current run
	    	app_tracefiles = adb_command("shell ls /sdcard/trace*/*"+appname+"*").translate(None, '\r').splitlines()
	    	for tracefile in app_tracefiles:
	    	    adb_command("pull "+tracefile+" "+ tdir(filename,appname))
                    print "pull "+tracefile+" "+ tdir(filename,appname)

	    	# remove all tracefiles from the current run
            	all_tracefiles = adb_command("shell ls -d /sdcard/trace*").translate(None, '\r').splitlines()
            	for tracefile in all_tracefiles:
            	    adb_command("shell rm -r "+tracefile)
                

                
            adb_command("shell rm -r /sdcard/*")
	    emulator_instance.terminate()
	#break
    return hasMainActivity



# parse the args
parser = argparse.ArgumentParser(description="This script collects traces of apks.")
parser.add_argument('-sb', dest='start_with',type=int, default=0, help='start with the i-th benign app')
parser.add_argument('-sm', dest='start_with_malicious',type=int, default=-1, help='start with the i-th malicious app')
args=parser.parse_args()

# first get all the files in the sample dir
malicious_samples = []
benign_samples = []

for filename in os.listdir(SAMPLES_BENIGN):
    if filename.endswith(".apk"):
        benign_samples.append(SAMPLES_BENIGN + "/" + filename)

for filename in os.listdir(SAMPLES_MALICIOUS):
    if filename.endswith(".apk"):
        malicious_samples.append(SAMPLES_MALICIOUS + "/" + filename)

benign_activities = get_package_name(benign_samples)
malicious_activities = get_package_name(malicious_samples)

print "Start: ", int(args.start_with)

if args.start_with_malicious == -1:
    nr_run_benign = run_instances(benign_activities, args.start_with)
nr_run_malicious = run_instances(malicious_activities, args.start_with_malicious)

#print "Found main Activity in ", nr_run_benign, " of " , len(benign_activities) , " benign Apps"
#print "Found main Activity in ", nr_run_malicious, " of " , len(benign_activities) , " malicious Apps"
